Just take the 5th root of the ciphertext, and voila!

```
def find_invpow(x,n):
    """Finds the integer component of the n'th root of x,
    an integer such that y ** n <= x < (y + 1) ** n.
    """
    high = 1
    while high ** n <= x:
        high *= 2
    low = high//2
    while low < high:
        mid = (low + high) // 2
        if low < mid and mid**n < x:
            low = mid
        elif high > mid and mid**n > x:
            high = mid
        else:
            return mid
    return mid + 1

c = 40030182544273856015788999062464973403472186630147528555052489762516210821795493031619376345647069575950526306492922573846162431037037824967074058132327917359025595463728944947118480605422897682821384491771926743103021286982319660969379132360886299787840185308892024028684314873509707776

n = 105764039675765007162224197946041421610988226034822789741202355465038405474039844301402146302908742536731331641437484787719599778194205333004482617077526529379473501342486898353691458150850096153562792549383987722885036435071184194348535804171098527517150958992100793020614109813938620093243709325590796177891

e = 5

m = find_invpow(c,e)
print(long_to_bytes(m))
```